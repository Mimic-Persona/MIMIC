const BOT_LOG_MSG = "bot_action.summarize:log";

const fs = require("fs");
const callOpenAI = require("../bridge/open_ai");
const {status2Prompt} = require("../bridge/client");
const {sendMessage} = require("../bridge/sendMessage");

/**
 * Transfer the given status into the wanted format for the event summarization
 * @param task The current task from the Planner
 * @param logMsg The log message created after running the plan
 * @returns {string} The status input for the event summarization
 */
function getEventStatusInput(task, logMsg) {
    let res = "Task: " + task + "\n";
    res += "Log Message: " + logMsg + "\n";
    return res;
}

/**
 * Summarize the given event
 * @param socket The WebSocket connection
 * @param memoryStream The memory stream
 * @param memoryType The type of the Memory, input should be 'event' / 'error'
 * @param previousStatusInput The previous status input
 * @param newStatusInput The new status input
 * @param plan The current plan by the Planner
 * @param expectation The expectation to the current plan
 * @param decision The current decision by the Decider
 * @param code The current code generated by the CodeGeneration
 * @param logMsg The log message created after running the code
 * @returns {Promise<Memory|null>} The Memory created after the summarization
 */

async function doEventSummary(socket, memoryStream, memoryType,
                              previousStatusInput, newStatusInput,
                              plan, expectation, decision, code,
                              logMsg) {

    let context = fs.readFileSync("./src/main/java/com/codecool/dungeoncrawl/agent/context/event_summarize_prompt.txt", 'utf8');

    let statusInput = getEventStatusInput(plan.task, logMsg);

    let newSummary = await callOpenAI(socket, context, statusInput, BOT_LOG_MSG, "gpt-4o", false, true);

    if (!newSummary) {
        sendMessage(socket, `${BOT_LOG_MSG} OpenAI response was empty. Ignore.`);

        return await memoryStream.addMemory(memoryType, true,
            0, 0, 0,
            plan.task, plan.action, plan.tile, plan.object,
            previousStatusInput, plan.reasoning, "", "", code, "", "", "");
    }

    let mySummary = JSON.parse(newSummary);
    let reasoning = mySummary.reasoning;
    let isSuccess = mySummary.success;
    let critique = mySummary.critique;

    return await memoryStream.addMemory(memoryType, isSuccess,
        0, 0, 0,
        plan.task, plan.action, plan.tile, plan.object,
        previousStatusInput.replaceAll("previous ", ""), plan.reasoning, "", reasoning, code, "", critique, "");
}

/**
 *
 * @param newErrorStatusInput The new status input
 * @param task The current task from the Planner
 * @param logMsg The log message created after running the code
 * @param errorMsg The error message created after running the code
 * @param isTimeOut If the code is timeout
 * @returns {string} The status input for the error summarization
 */
function getErrorStatusInput(newErrorStatusInput, task, logMsg, errorMsg, isTimeOut) {
    let res = newErrorStatusInput;
    res += "Task: " + task + "\n";
    res += "Log Message: " + logMsg + "\n";
    res += "Error Message: " + errorMsg + "\n";
    res += "Timeout: " + isTimeOut;
    return res;
}

/**
 * Summarize the given error
 * @param socket The WebSocket connection
 * @param memoryStream The memory stream
 * @param memoryType The type of the Memory, input should be 'event' / 'error'
 * @param previousErrorStatusInput The previous status input
 * @param newErrorStatusInput The new status input
 * @param plan The current plan by the Planner
 * @param decision The current decision by the Decider
 * @param code The current code generated by the CodeGeneration
 * @param logMsg The log message created after running the code
 * @param errorMsg The error message created after running the code
 * @param isTimeOut If the code is timeout
 * @returns {Promise<Memory|null>} The Memory created after the summarization
 */
async function doErrorSummary(socket, memoryStream, memoryType,
                              previousErrorStatusInput, newErrorStatusInput,
                              plan, decision, code, logMsg, errorMsg, isTimeOut) {

    let context = fs.readFileSync("./src/main/java/com/codecool/dungeoncrawl/agent/context/error_summarize_prompt.txt", 'utf8');

    let statusInput = getErrorStatusInput(newErrorStatusInput, plan.task, logMsg, errorMsg, isTimeOut);

    let newSummary = await callOpenAI(socket, context, statusInput, BOT_LOG_MSG, "gpt-4o", false, true);

    if (!newSummary) {
        sendMessage(socket, `${BOT_LOG_MSG} OpenAI response was empty. Ignore.`);

        return await memoryStream.addMemory(memoryType, false,
            0, 0, 0,
            plan.task, plan.action, plan.tile, plan.object,
            previousErrorStatusInput, plan.reasoning, "", "", code, "", "", errorMsg);
    }

    let mySummary = JSON.parse(newSummary);
    let reasoning = mySummary.reasoning;
    let isSuccess = mySummary.success;
    let critique = mySummary.critique;

    return await memoryStream.addMemory(memoryType, isSuccess,
        0, 0, 0,
        plan.task, plan.action, plan.tile, plan.object,
        previousErrorStatusInput, plan.reasoning, "", reasoning, code, "", critique, errorMsg);
}

/**
 * Do the summary for current event / error and store it in the given MemoryStream as a Memory
 * @param socket The WebSocket connection
 * @param basic_skills The basic skills provided to the bot
 * @param memoryStream The MemoryStream used to store the Memory
 * @param memoryType The type of the Memory, input should be 'event' / 'error'
 * @param previousStatus The status before the plan is acted
 * @param newStatus The status after the plan is acted
 * @param plan The current plan by the Planner
 * @param expectation The expectation to the current plan
 * @param decision The current decision by the Decider
 * @param code The current code generated by the CodeGeneration
 * @param logMsg The log message created after running the code
 * @param errorMsg The error message created after running the code
 * @param isTimeOut If the code is timeout
 * @returns {Promise<Memory|null>} The Memory created after the summarization
 */
async function summarize(socket, basic_skills, memoryStream, memoryType,
                         previousStatus, newStatus,
                         plan, expectation, decision, code, logMsg, errorMsg, isTimeOut) {

    if (memoryType === "event") {
        const previousEventStatusInput = status2Prompt(previousStatus, "previous ");
        const newEventStatusInput = status2Prompt(newStatus, "new ");

        return await doEventSummary(socket, memoryStream, memoryType,
            previousEventStatusInput, newEventStatusInput,
            plan, expectation, decision, code, logMsg);

    } else {
        const previousErrorStatusInput = status2Prompt(previousStatus);
        const newErrorStatusInput = status2Prompt(newStatus);

        return await doErrorSummary(socket, memoryStream, memoryType,
            previousErrorStatusInput, newErrorStatusInput,
            plan, decision, code, logMsg, errorMsg, isTimeOut);
    }
}

module.exports = {
    summarize,
};