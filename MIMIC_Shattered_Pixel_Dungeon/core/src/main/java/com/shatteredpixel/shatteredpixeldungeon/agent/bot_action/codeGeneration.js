const BOT_LOG_MSG = "bot_action.codeGeneration:log";


const {loadSkills} = require("../utils/file_utils");
const fs = require("fs");
const callOpenAI = require("../bridge/open_ai");

/**
 * Transfer the given status into the wanted format for the planner
 * @param {{}} status
 * @param {{}} inventory
 * @param {{}} task
 * @param code
 * @param errMsg
 * @param chatLog
 * @param critique
 * @returns {string}
 */
function statusToCodeInput(status, inventory, task, code, errMsg, chatLog, critique){
    let newStatus = "";
    newStatus += "Code from the last round: " + code + "\n";
    newStatus += "Execution error: " + errMsg + "\n";
    newStatus += "Chat log: " + chatLog + "\n";

    newStatus += "Biome: " + status.biome + "\n";
    newStatus += "Time: " + status.timeOfDay + "\n";
    newStatus += "Nearby blocks: {" + Array.from(status.blocks).join(', ') + "}\n";
    newStatus += "Nearby entities (nearest to farthest): " + JSON.stringify(status.entities) + "\n";
    newStatus += "Health: " + status.health + "\n";
    newStatus += "Hunger: " + status.food + "\n";
    newStatus += "Position: " + JSON.stringify(status.position) + "\n";
    newStatus += "Equipment: " + JSON.stringify(status.equipment) + "\n";
    newStatus += "Inventory (" + Object.keys(inventory).length + "/36): " + JSON.stringify(inventory) + "\n";
    newStatus += "Task: " + task + "\n";

    newStatus += "Critique: " + critique + "\n";

    return newStatus;
}

/**
 * Generate the code according to the given task
 * @param memoryStream
 * @param skillManager
 * @param BASIC_SKILL_PATH
 * @param SKILLS_PATH
 * @param {string} task The task to be achieved
 * @param {string[]} basic_skills The given basic skills to achieve the task
 * @param status
 * @param inventory
 * @param previousCode
 * @param errMsg
 * @param chatLog
 * @param critique
 * @returns {Promise<{explain, code, plan}>} The code generated by the Codex
 */
async function codeGeneration(memoryStream, skillManager, BASIC_SKILL_PATH, SKILLS_PATH,
                              task, basic_skills, status, inventory,
                              previousCode="", errMsg="", chatLog="", critique="") {

    const BS = await loadSkills(basic_skills, BASIC_SKILL_PATH);

    const relatedSkills = await skillManager.retrieveSkills(task);
    // console.log(relatedSkills);

    let RS = await loadSkills(relatedSkills, SKILLS_PATH);
    // console.log(RS);
    RS = RS.replaceAll(skillManager.skills_import, '\n');

    // TODO: Remove the skills imports when adding to the context
    let context = fs.readFileSync("./core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/agent/context/code_generation_prompt.txt", 'utf8');
    context = context.replace("{Basic_Skills}", BS);
    context = context.replace("{Skills}", RS);

    let currStatus = statusToCodeInput(status, inventory, task, previousCode, errMsg, chatLog, critique)

    // FIXME: Bad Request sometimes because of large context
    let result = await callOpenAI(socket, context, currStatus, BOT_LOG_MSG, "gpt-4o", true, true);

    if (!result) {
        console.log(BOT_LOG_MSG, "OpenAI response was empty. Ignore.");
        return null;
    }

    // Extract the answers
    let explain = result.slice(result.indexOf("Explain (if applicable):") + 24, result.indexOf("Function Name:")).trim();
    let name = result.slice(result.indexOf("Function Name:") + 14, result.indexOf("Programs Used:")).trim();
    let skills = result.slice(result.indexOf("Programs Used:") + 14, result.indexOf("Design:")).trim().split(', ');
    let design = result.slice(result.indexOf("Design:") + 7, result.indexOf("Code:")).trim();
    let code = result.slice(result.indexOf("```javascript") + 13, result.indexOf("```", result.indexOf("```") + 1)).trim();

    return {
        explain: explain,
        name: name,
        skills: skills,
        relatedSkills: relatedSkills,
        design: design,
        code: code
    };
}


module.exports = codeGeneration;